<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Whiteboard</title>
        <script src="https://cdn.tailwindcss.com"></script>
        <style>
            /* Ensures the canvas fills its container and handles touch/cursor */
            #whiteboard {
                touch-action: none; 
                cursor: crosshair;
                background-color: #ffffff;
            }
        </style>
        <script>
            tailwind.config = {
                theme: {
                    extend: {
                        fontFamily: {
                            sans: ['Inter', 'sans-serif'],
                        },
                    }
                }
            }
        </script>
    </head>
    <body class="bg-gray-50 flex flex-col min-h-screen font-sans antialiased p-4">

        <h1 class="text-3xl font-bold text-gray-800 mb-6 text-center">Whiteboard</h1>

        <div id="controls" class="bg-white p-4 rounded-xl shadow-lg mb-6 flex flex-wrap justify-center items-center gap-4">
            
            <div class="flex items-center space-x-2">
                <label for="colorPicker" class="text-sm font-medium text-gray-700">Color:</label>
                <input type="color" id="colorPicker" value="#000000" class="w-12 h-8 rounded-md overflow-hidden border-2 border-gray-200 cursor-pointer">
            </div>

            <div class="flex items-center space-x-2 w-full sm:w-auto">
                <label for="sizeSlider" class="text-sm font-medium text-gray-700 whitespace-nowrap">
                    Size (<span id="currentSize">5</span>px): 
                </label>
                <input type="range" id="sizeSlider" min="1" max="50" value="5" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
            </div>

            <div class="flex bg-gray-100 rounded-lg p-1">
                <button id="penButton" class="px-3 py-1 bg-white shadow text-gray-700 font-medium rounded-md mr-1 hover:text-indigo-600 transition">
                    ‚úèÔ∏è Pen
                </button>
                <button id="eraserButton" class="px-3 py-1 text-gray-600 font-medium rounded-md hover:bg-white hover:shadow hover:text-indigo-600 transition">
                    üßπ Eraser
                </button>
            </div>

            <button id="undoButton" class="px-4 py-2 bg-indigo-500 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-600 transition duration-150 ease-in-out">
                Undo
            </button>

            <button id="saveButton" class="px-4 py-2 bg-green-500 text-white font-semibold rounded-lg shadow-md hover:bg-green-600 transition duration-150 ease-in-out">
                üíæ Save
            </button>

            <button id="clearButton" class="px-4 py-2 bg-red-500 text-white font-semibold rounded-lg shadow-md hover:bg-red-600 transition duration-150 ease-in-out">
                Clear
            </button>
        </div>

        <div class="shadow-2xl rounded-xl overflow-hidden bg-white flex-grow max-w-full mx-auto border border-gray-300" style="aspect-ratio: 16 / 9; width: 100%;">
            <canvas id="whiteboard" class="w-full h-full"></canvas> 
        </div>

        <script>
            let canvas, ctx;
            let isDrawing = false;
            let lastX = 0;
            let lastY = 0;

            let modifiedBoard = false; 
            let history = [];
            let historyIndex = -1;
            
            // Current tool settings
            let currentColor = document.getElementById('colorPicker').value;
            let currentSize = parseInt(document.getElementById('sizeSlider').value);
            let isEraserMode = false;


            // Updates the canvas dimensions 
            function resizeCanvas() {
                // Determine if we need to save content before resize (optional, but resizing clears canvas usually)
                // For this simple version, we'll just resize. Ideally, you copy content to temp canvas and put it back.
                const rect = canvas.getBoundingClientRect();
                
                // Only resize if dimensions actually changed to prevent mobile url bar glitches
                if(canvas.width !== rect.width || canvas.height !== rect.height) {
                    canvas.width = rect.width; 
                    canvas.height = rect.height;
                }

                // Restore the drawing style settings after resizing/init
                updateContextStyle();
            }

            function updateContextStyle() {
                ctx.lineWidth = currentSize;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                if (isEraserMode) {
                    ctx.strokeStyle = '#ffffff';
                } else {
                    ctx.strokeStyle = currentColor;
                }
            }

            // Get mouse coordinates 
            function getCoordinates(e) {
                const rect = canvas.getBoundingClientRect();
                let clientX, clientY;
                if (e.touches && e.touches.length > 0) {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }

                return {
                    x: clientX - rect.left,
                    y: clientY - rect.top
                };
            }

            function draw(x, y) {
                if (!isDrawing) return;

                modifiedBoard = true;
                
                ctx.beginPath();
                ctx.moveTo(lastX, lastY); 
                ctx.lineTo(x, y);         
                ctx.stroke();             

                [lastX, lastY] = [x, y];
            }

            function saveState() {
                if (historyIndex < history.length - 1) {
                    history = history.slice(0, historyIndex + 1);
                }
                const dataURL = canvas.toDataURL();
                history.push(dataURL);
                historyIndex++;
            }

            function undo() {
                if (historyIndex > 0) {
                    historyIndex--;
                    const image = new Image();
                    image.onload = function() {
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        ctx.drawImage(image, 0, 0, canvas.width, canvas.height);
                        updateContextStyle(); // Restore styles after undo redraw
                    };
                    image.src = history[historyIndex];
                }
            }

            function startDrawing(e) {
                e.preventDefault();
                isDrawing = true;
                modifiedBoard = false; 
                ({ x: lastX, y: lastY } = getCoordinates(e));
            }

            function drawing(e) {
                e.preventDefault();
                if (!isDrawing) return;
                const coords = getCoordinates(e);
                draw(coords.x, coords.y);
            }

            function stopDrawing() {
                isDrawing = false;
                if (modifiedBoard) {
                    saveState();
                }
            }

            function initWhiteboard() {
                canvas = document.getElementById('whiteboard'); 
                ctx = canvas.getContext('2d');
                
                resizeCanvas();
                window.addEventListener('resize', resizeCanvas);

                // UI Elements
                const colorPicker = document.getElementById('colorPicker');
                const sizeSlider = document.getElementById('sizeSlider');
                const currentSizeSpan = document.getElementById('currentSize'); 
                const clearButton = document.getElementById('clearButton');
                const undoButton = document.getElementById('undoButton'); 
                const saveButton = document.getElementById('saveButton');
                const penButton = document.getElementById('penButton');
                const eraserButton = document.getElementById('eraserButton');

                // --- Event Listeners ---

                colorPicker.addEventListener('input', (e) => {
                    currentColor = e.target.value;
                    // If user picks a color, automatically switch back to pen mode
                    if(isEraserMode) switchTool('pen');
                    else updateContextStyle();
                });

                sizeSlider.addEventListener('input', (e) => {
                    currentSize = parseInt(e.target.value);
                    if (currentSizeSpan) currentSizeSpan.textContent = currentSize;
                    updateContextStyle();
                });

                // Tool Switching Logic
                function switchTool(tool) {
                    if (tool === 'eraser') {
                        isEraserMode = true;
                        penButton.classList.remove('bg-white', 'shadow');
                        eraserButton.classList.add('bg-white', 'shadow');
                    } else {
                        isEraserMode = false;
                        eraserButton.classList.remove('bg-white', 'shadow');
                        penButton.classList.add('bg-white', 'shadow');
                    }
                    updateContextStyle();
                }

                penButton.addEventListener('click', () => switchTool('pen'));
                eraserButton.addEventListener('click', () => switchTool('eraser'));

                undoButton.addEventListener('click', undo);

                clearButton.addEventListener('click', () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    history = [];
                    historyIndex = -1;
                    saveState();
                });

                // SAVE FEATURE
                saveButton.addEventListener('click', () => {
                    const link = document.createElement('a');
                    link.download = 'whiteboard.png';
                    
                    // Create temporary canvas to handle background color
                    const tempCanvas = document.createElement('canvas');
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCanvas.width = canvas.width;
                    tempCanvas.height = canvas.height;

                    // Fill white background first (avoid transparent background)
                    tempCtx.fillStyle = '#ffffff';
                    tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
                    
                    // Draw the drawing on top
                    tempCtx.drawImage(canvas, 0, 0);

                    link.href = tempCanvas.toDataURL();
                    link.click();
                });
                
                // Drawing Listeners
                canvas.addEventListener('mousedown', startDrawing);
                canvas.addEventListener('mousemove', drawing);
                canvas.addEventListener('mouseup', stopDrawing);

                canvas.addEventListener('touchstart', startDrawing);
                canvas.addEventListener('touchmove', drawing);
                canvas.addEventListener('touchend', stopDrawing);

                saveState();
            }

            // Start
            window.onload = initWhiteboard;

        </script>
    </body>
</html>